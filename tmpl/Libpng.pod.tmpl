[% start_year=2011 %]
[% danger="‚õêü§™‚ö†" %]
[%- noinfo = "No info structure" -%]
[%- xnoinfo = BLOCK -%]
L</[% noinfo %]>
[%- END -%]
[%-  noinfoxref = BLOCK -%]
It does not take a second "info" argument. See [% xnoinfo -%].
[%- END -%]
[% transform_list = BLOCK %]
=over
[% FOR transform IN transforms %]
=item [% transform.name %]

[% transform.text %]
[% END %]
=back
[% END %]
[% libpngdoc = "The libpng documentation" %]
[% pngspec = "The PNG specification" %]
[% MACRO spec(subsection) BLOCK -%]
L<this subsection|http://www.w3.org/TR/PNG/#[%- subsection -%]>
of L</[% pngspec %]>
[%- END %]
[%- wfirstpng = BLOCK -%]
The first argument, C<$png>, is a writeable PNG structure created with 
L</create_write_struct>.
[%- END -%]
[%- rfirstpng = BLOCK -%]
The first argument, C<$png>, is a PNG structure created with 
L</create_read_struct>.
[%- END -%]
[%- MACRO cor BLOCK -%]
This function corresponds to C<png_[% fn %]> in libpng
[%- END %]
[%- MACRO supports BLOCK -%]
You can test whether your version of libpng supports [% desc %]
with L</libpng_supports> as follows:

    if (libpng_supports ('[% val %]')) {
        # do something
    }
[%- END %]
[% source_link = "http://cpansearch.perl.org/src/" _ config.author_pause _ "/" _ config.base_hyphen _ "-" _ config.version _ "/" %]
[% perl_libpng_c = "L<in the file C<perl-libpng.c> in the top directory of the distribution|" _ source_link  _ "perl-libpng.c>" %]
[% unused_title = "Unused arguments omitted" %]
[% unused = "See L<" _ unused_title _ ">." %]
[%- MACRO example(pl) BLOCK %]
[%- file = pl _ ".pl" %]
[%- INCLUDE $file | xtidy %]
(This example is included as L<F<[% file %]>|https://fastapi.metacpan.org/source/BKB/Image-PNG-Libpng-[% config.version %]/examples/[% file %]> in the distribution.)

[%- END # macro -%]

=pod

=encoding UTF-8

=head1 NAME

Image::PNG::Libpng - Perl interface to the C library "libpng".

=head1 SYNOPSIS

[% example('synopsis') %]

=head1 VERSION

This document describes Image::PNG::Libpng version [% config.version
%], corresponding to git commit L<[% commit.commit %]|[% config.repo
%]/commit/[% commit.commit %]> at [% commit.date %].

Unless otherwise qualified, comments in this document on the libpng
source code and documentation refer to libpng version [%
config.mylibpng %]. Libpng is not bundled with this distribution, so
your installed version may vary.

=head1 DESCRIPTION

Image::PNG::Libpng is a Perl library for accessing the contents of PNG
(Portable Network Graphics) images. Image::PNG::Libpng enables Perl to
use the "libpng" library to read and write files in PNG
format. Image::PNG::Libpng does not contain the libpng library. The
libpng library must be installed on your computer prior to installing
Image::PNG::Libpng.

Image::PNG::Libpng consists of Perl subroutines which mirror
the C functions in libpng, plus helper subroutines to make it easier
to read and write PNG data in Perl. 

For those familiar with libpng, the section L</Differences
from libpng> explains the differences with libpng.

=head1 FUNCTIONS

The functions in the module are gathered into the following
categories: L</Simple input and output>, which describes some
convenience functions, L</Input and output libpng style>, which
describes functions which closely mirror libpng, L</The image header>,
which describes functions for reading and writing the meta-information
about PNG images, L</Image data>, which describes functions for
accessing the image data itself, L</PNG timestamps>, L</Text chunks>,
L</Private chunks>, L</Helper functions>, L</Library version
functions>, L</Palettes>, for handling paletted images, L</Compression
and filtering>, and L</Other chunks>. There are also L</META
FUNCTIONS> for examining your installed libpng, L</UNDOCUMENTED
FUNCTIONS>, and L</TESTING FUNCTIONS> which are functions used in
testing this module itself.

=head1 Simple input and output

These convenience functions combine common operations. They are not
part of the original libpng API.

=head2 read_png_file

     my $png = read_png_file ('q.png');

Open F<q.png> and read its contents into C<$png>.

This combines L</create_read_struct>, open, L</init_io>, and
L</read_png>. The return value is the same as that of
L</create_read_struct> with the entire PNG image already read in.

The optional argument to L</read_png> can be specified using an
optional C<transforms> argument:

    my $png = read_png_file ('file.png', transforms => PNG_TRANSFORM_EXPAND);

L<Carp/croak> is used to signal errors opening or closing the file.

=head2 write_png_file

    $png->write_png_file ('nice.png');

This combines open, L</init_io>, and L</write_png> to write an entire
PNG image out to the file name specified by the argument. C<$png> must
be the object created by L</create_write_struct>, so L</read_png_file>
followed by a call to this does not work. See L</copy_png> if you need
to do that kind of operation.

The optional argument to L</write_png> can be specified using
L</set_transforms>.

L<Carp/croak> is used to signal errors opening or closing the file.

=head2 read_from_scalar

     my $png = read_from_scalar ($string);

This creates an image structure C<$png> from the contents of a Perl
scalar variable C<$string> containing PNG image data, for example data
read from a file, or data obtained from a web page. [% rfirstpng %] It
reads in all the data from the structure on being called.

This is useful when image data is stored in a Perl scalar. For example

[% example('get-www-png') %]

See also L</Input/output manipulation functions>.

=head2 write_to_scalar

    my $image_data = $png->write_to_scalar ();

This writes the PNG image data in C<$png> into a Perl scalar. [%
wfirstpng %] The return value of the subroutine is the Perl scalar
containing the image data.

So, for example,

[% example('png-cgi') %]

See also L</Input/output manipulation functions>.

The optional argument to L</write_png> can be specified using
L</set_transforms>.

=head2 copy_png

    my $outpng = $png->copy_png ();

Copy a PNG from a read to a write structure. This function bridges two
kinds of object, "read a png" objects created by
L</create_read_struct> and "write a png" objects created by
L</create_write_struct>. This function copies all the valid chunks
from a read structure to a write structure.

The following example demonstrates copying a PNG.

[% example('copy-png') %]

=head2 set_transforms

    $png->set_transforms (PNG_TRANSFORM_BGR);

Set transforms for reading and writing. This is the same as the
optional argument to L</read_png> or L</write_png>. If both this and
the optional argument are given, the optional argument overrides what
is set here.

=head2 png_compare

    if (png_compare ('a.png', 'b.png') == 0) {
	print "The PNGs are the same.\n";
    }

This compares the image data in two PNGs and returns 0 if they contain
exactly the same image data, or 1 if they contain different image
data. For a more detailed comparison, see L</image_data_diff>. This
does not compare to see if the PNG files "look like" each other, but
whether each pixel contains exactly the same values. Please see
L<Image::Similar> for a looser comparison of images.

=head2 get_chunk

    my $timechunk = $png->get_chunk ('tIME');

Get the specified chunk. This produces a fatal error if asked for the
C<IDAT> (image data) chunk, use L</get_rows> instead. Returns undef if
asked for an unknown chunk name.

This is used by L<pnginspect> to get the valid chunks.

=head2 set_chunk

    $png->set_chunk ('tIME', $timechunk);

Set the specified chunk. This produces a fatal error if given an
C<IDAT> (image data) chunk, use L</set_rows> instead. Produces a fatal
error if given an unknown chunk name.

=head2 split_alpha

    my $split = $png->split_alpha ();
    my $alpha = $split->{alpha};
    my $colour = $split->{data};

Split the alpha channel away from the other data. This only works for
RGBA images or gray/alpha images. This is not part of the libpng API,
it was added to this module to assist the author of L<PDF::Builder>.

If your purpose of splitting out the Alpha channel is simply to
discard it, you may get better performance by using
C<PNG_TRANSFORM_STRIP_ALPHA> in L</read_png> instead.

=head1 New-like functions

There are two different "new"-like functions, depending on whether you
want to read or write a PNG. (See L</copy_png> for a function to copy
one to the other.) These are based on the libpng API.

=head2 create_read_struct

     my $png = create_read_struct ();

Create a structure for reading a PNG. The return value can be used as
an object with the other functions as methods. It can be copied to a
write structure with L</copy_png>.

[% cor(fn="create_read_struct") %] plus C<create_info_struct> (see [%
xnoinfo %]) with the error and warning handler variables set up to use
Perl's error reporting.

=head2 create_write_struct

     my $png = create_write_struct ();

Create a structure for writing a PNG. This can be used as an object
with the other functions as methods.

[% cor(fn="create_write_struct") %] plus C<create_info_struct> (see [%
xnoinfo %])  with the error and warning handler variables set up to use
Perl's error reporting.

=head1 Input and output libpng style

These functions mirror libpng's API.

=head2 init_io

     open my $file, "<", 'nice.png';
     $png->init_io ($file);

Set the file which C<$png> reads or writes to C<$file>. C<$file> must
be an already-opened Perl file handle. If C<$png> was created with
L</create_write_struct>, C<$file> must be opened for writing. If
C<$png> was created with L</create_read_struct>, C<$file> must be open
for reading.

Since PNG files are binary files, it is safest to specify the "raw"
pragma or use "binmode" with the file to override any default text
file encoding which Perl might be using:

     open my $file, ">:raw", 'output.png';

or

     open my $file, ">", 'output.png';
     binmode $file;

[% cor(fn="init_io") %], with a Perl
file handle substituting for the C C<FILE *>.

=head2 read_png

     $png->read_png ();

Read the entire PNG file into memory. 

You can provide an argument containing transformations to apply to the
image:

     use Image::PNG::Const qw/PNG_TRANSFORM_STRIP_ALPHA/;
     $png->read_png (PNG_TRANSFORM_STRIP_ALPHA);

If the argument is omitted, the default value of
C<PNG_TRANSFORM_IDENTITY> (the "do nothing" value) is applied. The
possible transformations which can be applied are

[%- transform_list -%]

[% cor(fn="read_png") %] with a default value for the third
argument. The fourth, unused, argument to C<png_read_png> does not
need to be supplied. [% unused %]

[% noinfoxref %]

=head2 write_png

    $png->write_png ();

This writes the PNG to the file stream which was associated with it
using L</init_io>. For example,

    open my $output, ">:raw", 'out.png';
    $png->init_io ($output);
    $png->write_png ();
    close $output;

An optional argument consists of transformations to apply to the PNG
image before writing it:

    use Image::PNG::Const qw/PNG_TRANSFORM_STRIP_ALPHA/;
    $png->write_png (PNG_TRANSFORM_STRIP_ALPHA);

The transformations which can be applied are as follows:

[% transform_list %]

[% danger %] NOTE: this list is untested and might be wrong. It was
just copied from the linux lib web pages, and the linux lib web pages
have different transformations for the read and write png functions.

[% cor(fn="write_png") %].

=head1 The image header

These functions handle the header part of PNG image data. See [%
spec("11IHDR") %] for information on the PNG standards for the image
header.

=head2 sig_cmp

    if (sig_cmp ($should_be_png)) {
        print "Your data does not have a PNG signature.\n";
    }

This subroutine looks at C<$should_be_png> and checks whether its
first bytes correspond to a valid PNG signature. It returns a true
value if they do not. 

It can also take two further arguments consisting of a byte offset and
a number of bytes to check respectively:

    sig_cmp ($should_be_png, 0, 8);

If these arguments are not supplied, the byte offset is assumed
to be zero, and the number of bytes to check is assumed to be eight.

[% cor(fn="sig_cmp") %], with default arguments of
0 and 8 if second and third arguments are not supplied.

=head2 get_valid

    my $valid = $png->get_valid ();
    if ($valid->{oFFs}) {
        print "The PNG has valid screen offsets.\n";
    }

This function returns a hash with a key for each possible chunk which
may or may not be valid. The chunks which you can test for are 
[% FOR chunk IN chunks %]L<[% IF chunk.defined('redirect') %][% chunk.name %]|/[% chunk.redirect %][% ELSE %]/[% chunk.name %][% END %]>[% IF loop.count < loop.size - 1 %], [% ELSIF loop.count == loop.size - 1 %], and [% END %][% END %].

Whereas L</libpng_supports> tells you whether the installed libpng on
your system supports various chunks, this tells you whether the chunks
are present in a particular PNG image file.

[% rfirstpng %]

[% cor(fn = "get_valid") %], with the difference being that the
return value is a hash containing a key for each possible chunk.

=head2 get_IHDR

    my $IHDR = $png->get_IHDR ();

Read the IHDR information from the PNG file. The return value is a
hash reference containing the following key/value pairs:

=over

[% FOR field IN ihdr_fields -%]
[%- IF ! field.defined('unused') %]
=item [% field.name %]

[%- IF field.defined('text') %]
[% field.text %]
[%- END -%]
[%- IF field.defined('retvalues') -%]
This can take the values [% field.retvalues.join (", ") %].
[%- END %]
[%- END %]

[%- END %]

=back

So, for example, to get the width and height of an image,

    my $ihdr = $png->get_IHDR ();
    printf "Your image is %d x %d\n", $ihdr->{width}, $ihdr->{height};

[% cor(fn="get_IHDR") %], with a single Perl hash reference used
instead of the several pointers to integers used in libpng. 

[% danger %] It does not return the fields C<filter_method> and
C<compression_method>, which are always 0. [% unused %]

=head2 set_IHDR

    my $ihdr = { width => 10, height => 10, bit_depth => 8,
                 color_type => PNG_COLOR_TYPE_RGB };
    $png->set_IHDR ($ihdr);

Set the IHDR chunk (the image header) of the PNG image. 

[% wfirstpng %] The second argument is a hash with the following values:

=over

[% FOR field IN ihdr_fields -%]
[%- IF ! field.defined('unused') %]
=item [% field.name %]

[% IF field.defined('text') %][% field.text %] [% END -%]
[%- IF field.defined('set') %][% field.set %] [% END -%]
[%- IF field.defined('retvalues') -%]
This can have the values [% field.retvalues.join (", ") %].
[%- END %]
[%- END %]

[%- END %]

=back

Other fields in the hash are ignored.

[% cor(fn="set_IHDR") %], with a single Perl hash reference
used instead of the seven integers. 

[% danger %] The variables
[% FOR field IN ihdr_fields -%]
[%- IF field.defined('unused') -%]
C<[%- field.name %]>, [% END -%]
[%- END %]
in C<png_set_IHDR> can only take one possible value, 0, so the routine
ignores them. [% unused %]

=head2 get_color_type

    my $color_type;
    $png->get_color_type (\$color_type);

This returns an integer value. If you want to get a name for the
colour type, use L</color_type_name>.

[% cor(fn="get_color_type") %].

=head2 color_type_name

    $name = color_type_name ($color_type);

Given a numerical colour type in C<$color_type>, return the equivalent
name. The name is in upper case, with words separated by underscores,
as in C<RGB_ALPHA>.

[% example('color-type-name') %]

This function does not correspond to anything in libpng. The names of
the colour types are taken from those defined in the libpng header
file, C<png.h>.

[% FOR what IN ['width', 'height'] %]

=head2 get_image_[% what %]

    my $[% what %] = $png->get_image_[% what %] ();

Get the image's [% what %] from the header.

[% cor(fn="get_image_" _ what) %]

=head2 [% what %]

    my $[% what %] = $png->[% what %] ();

Alias for L</get_image_[% what %]>. This is not exported, it's
intended for use with the object only.

[% END # what %]

=head2 get_channels

    my $channels = $png->get_channels ();

Get the number of channels, from one to four. This means the number of
components of one pixel. The return value is 1 for colour type
PNG_COLOR_TYPE_GRAY and PNG_COLOR_TYPE_PALETTE, 2 for
PNG_COLOR_TYPE_GRAY_ALPHA, 3 for PNG_COLOR_TYPE_RGB and 4 for
PNG_COLOR_TYPE_RGB_ALPHA or PNG_COLOR_TYPE_RGB with a filler
byte. This doesn't necessarily correspond to the number of bytes,
since the bit depth can also be 1, 2, 4, 8, or 16.

[% cor(fn="get_channels") %]

=head2 get_bit_depth

    my $bit_depth = $png->get_bit_depth ();

Get the bit depth, the number of bits for one channel of one pixel.

[% cor(fn="get_bit_depth") %]

=head2 get_interlace_type

    my $interlace_type = $png->get_interlace_type ();

Get the interlace type. This is either PNG_INTERLACE_NONE or
PNG_INTERLACE_ADAM7.

[% cor(fn="get_interlace_type") %]

=head1 Image data

These functions deal with accessing the image data itself.

=head2 get_rows

    my $rows = $png->get_rows ();
    my $pixel = substr ($rows->[10], 20, 1);

This returns the rows of the PNG image, after uncompressing and
unfiltering, as binary data. The return value, C<$rows> in the
example, is an array reference with a number of rows equal to the
height of the PNG image. Each element of the array reference is a
string containing the binary data making up a row of the image. The
values of individual pixels can be extracted from using a function
such as C<substr> or C<unpack>. This binary data is likely to contain
bytes equal to zero.

L</get_rowbytes> gives the number of bytes in each row.

Each row is a Perl string. Perl terminates each row of data with an
extra zero byte at the end.

[% cor(fn="get_rows") %].

=head2 set_rows

    $png->set_rows (\@rows);

Set the rows of data to be written in to the PNG to C<@rows>. C<@rows>
needs to contain at least the same number of rows of data as the
height of the PNG image set with L</set_IHDR>, and the length of each
entry needs to be at least the width of the image multiplied by the
number of bytes required for each pixel.

This function was changed to copy the data in version 0.46.

[% cor(fn="set_rows") %].

=head2 get_rowbytes

    my $bytes_in_a_row = $png->get_rowbytes ();

This returns the number of bytes needed to hold a transformed row of
an image.

[% cor(fn="get_rowbytes") %].

=head1 PNG timestamps

See [% spec("11timestampinfo") %] for information on the PNG standards for
time stamp information.

=head2 get_tIME

    my $time = $png->get_tIME ();
    if ($time && $time->{year} < 2005) {
        warn "Your PNG is now getting old. Don't forget to oil it to prevent rust.";
    }

The return value is either the undefined value, if no C<tIME> chunk
exists in the PNG, or a hash reference containing fields "year",
"month", "day", "hour", "minute" and "second". "Month" and "day" start
from 1 rather than 0.

The "modification time value" of the PNG image is a chunk written into
the PNG file itself, and may not have the same value as the operating
system's modification time for the file. The tIME chunk is not a
compulsory requirement for PNG files, and most PNG image files do not
contain this chunk. 
[%- MACRO timezone BLOCK -%]
PNG tIME chunks do not contain a time zone. According to [%
spec("11tIME") %], "Universal Time (UTC) should be specified rather
than local time."
[%- END -%]
[% timezone %]

[% cor(fn="get_tIME") %], with a Perl hash reference
substituted for the C struct C<png_timep> used in libpng.

=head2 set_tIME

    # Set the time to "now"
    $png->set_tIME ();
    # Set the time
    $png->set_tIME ({year => 1999, month => 12});

Set the modification time of the PNG to the values given by the
argument, a hash reference containing the fields C<year>, C<month>,
C<day> for the day of the month, C<hour>, C<minute>, and C<second>.
The numbering for C<month> and C<day> is from 1, not 0. If any of
year, hour, minute or second is omitted from the hash reference, these
are set to zero. If month or day are omitted, these are set to 1.  [%
timezone %] If the entire argument is omitted or contains an invalid
value, the time is set to the current time.

[% cor(fn="set_tIME") %], with a Perl hash reference
substituted for the C struct C<png_timep> used in libpng.

=head1 Text chunks

See [% spec("11textinfo") %] for information on the PNG standards for
text information.

=head2 get_text

    my $text_chunks = $png->get_text ();

This gets all of the text chunks in the PNG image and returns them as
an array reference. Each element of the array represents one text
chunk. This element is a hash reference with keys such as C<key>,
C<lang_key>, or C<compression> taken from the PNG's information.

The text data is uncompressed by libpng. If it is international text
(C<ITXT>), it is put into Perl's internal Unicode encoding if it is
found to be valid UTF-8. (PNG "international text", C<ITXT> is
required to be in the UTF-8 encoding, and non-international text is
required to contain whitespace and printable ASCII characters
only. See L</[% pngspec %]> for more on the requirements of a PNG text
section.)

[% cor(fn="get_text") %], with a Perl array of hash references
substituted for the C array of structs used by libpng. See
L</set_text> for details of the keys and values which may be returned.

=head2 set_text

    $png->set_text ([\%chunk1, \%chunk2]);

This sets the text chunks in a writeable image. The input value is an
array reference containing one or more hash references. Each hash
reference must have a C<key> value for the text. According to the PNG
specification, this should be between one and 79 bytes in length. This
module enforces that restriction, so if you supply a key longer than
that, the chunk cannot be added. A hash reference may also have the
following:

=over

=item C<text>

The value of "text" is added to the PNG as the text segment.

=item C<compression>

The value of C<compression> controls the compression of the
text. If C<compression> is not supplied, a default value of
PNG_TEXT_COMPRESSION_NONE is applied. The C<compression> field can
take the following values, available from L<Image::PNG::Const>:

=over

=item PNG_TEXT_COMPRESSION_NONE

TEXT = Printable ASCII and space characters.

=item PNG_TEXT_COMPRESSION_zTXt

TEXT = Printable ASCII and space characters.

=item PNG_ITXT_COMPRESSION_NONE

ITXT = International text, should be UTF-8.

=item PNG_ITXT_COMPRESSION_zTXt

ITXT = International text, should be UTF-8.

=back

=item C<itxt_length>

The string length of international text in bytes.

[% danger %] This is ignored by libpng when writing text chunks. When
reading text chunks, if the text is marked as international text,
libpng adds the length of the string in bytes in this field rather
than in L</text_length>.

=item C<lang>

This should be set to name of the language of the text, if the text
chunk is iTXt. According to the PNG specification, "It is an ISO
646.IRV:1991 [ISO 646] string consisting of hyphen-separated words of
1-8 alphanumeric characters each (for example cn, en-uk, no-bok,
x-klingon, x-KlInGoN)." 

Support for writing C<lang> was added in version 0.49 of this
module. (Prior to that undocumented support existed via a
differently-named key.)

[% danger %] This module does not attempt to check the supplied value,
but merely passes it to libpng. libpng appears not to check the value
either, nor to enforce restrictions on its length.

=item C<lang_key>

This corresponds to the "Translated keyword" of the PNG
specification. Note that the user needs to supply C<key> and L</lang>
as well as C<lang_key>.

Support for writing C<lang_key> was added in version 0.49 of this
module.  (Prior to that undocumented support existed via a
differently-named key.)

=item C<text_length>

The string length in bytes. The user may set this, but it is ignored
when writing PNG text chunks, instead this module uses the string
length obtained from Perl. This key contains the length of the string
when reading text chunks via L</get_text>, but if the text is marked
as international text, L</itxt_length> is used to return its length in
bytes, rather than this.

=back

Whether or not the value of C<text> is an ITXT field is decided by the
value of C<compression>. 

People who want to fiddle with the text compression applied can do so
via L</set_text_compression_level> and the other functions described
below that.

If C<set_text> is called more than once, the chunks are not overwritten but
appended to the existing ones. (This behaviour is from libpng itself.)

Prior to version 0.50, C<set_text> would fail silently if the user
added invalid chunks, for example hash references without a valid
C<key>, or things which were not hash references at all. From version
0.50, all invalid inputs cause fatal errors. However, unknown keys in
the hash references do not cause fatal errors.

[% cor(fn="set_text") %].

=head3 Example

[% example('set-text') %]

=head1 Private chunks

See [% spec("12Use-of-private-chunks") %] for information on the PNG
standards for private chunks.

[% supports(desc="private chunks",val="UNKNOWN_CHUNKS") %]

=head2 set_keep_unknown_chunks

    use Image::PNG::Const 'PNG_HANDLE_CHUNK_ALWAYS';
    $png->set_keep_unknown_chunks (PNG_HANDLE_CHUNK_ALWAYS);

Tell libpng not to discard unknown chunks when reading the file.

=head2 get_unknown_chunks

    my $private_chunks = $png->get_unknown_chunks ();
    # Get some data from a private chunk
    my $chunk_three_data = $private_chunks->[3]->{data};
    # Get the size of the data
    print length $chunk_three_data;

This gets all of the private chunks from the image. The return value
is an array reference containing hash references. If there are no
private chunks, this returns an undefined value. There is one element
of the array for each chunk member. It is necessary to call
L</set_keep_unknown_chunks> with an appropriate value before reading
the file, otherwise libpng discards unknown chunks when reading the
file.

Each member hash reference has the following keys:

=over
[% FOR field IN unknown_chunk_fields %]
=item [% field.name %]

[% field.description %]
[% END %]
=back

The "size" field of the PNG structure is not stored, because the
"data" member of the hash contains information on its length.

[% cor(fn="get_unknown_chunks") %]

=head2 set_unknown_chunks

[% danger %] This currently does not fully function.

[% cor(fn="set_unknown_chunks") %]

=head1 Helper functions

These helper functions assist the programmer in the transition from
libpng, which uses C conventions such as upper case macros standing
for numerical constants and C structures, to Perl's string-based
conventions.

=head2 text_compression_name

    my $name = Image::PNG::Libpng::text_compression_name ($text->{compression});

Given a numerical text compression type, return the equivalent
name. The name is in upper case. The possible return values are

=over

=item TEXT_NONE

=item TEXT_zTXt

=item ITXT_NONE

=item ITXT_zTXt

=item an empty string

if the compression method is unknown.

=back

The compression field is also used to store the information about
whether the text is "international text" in UTF-8 or not.

This function does not correspond to anything in libpng. The names of
the text compression types are based on those in C<png.h>, but without
the word "COMPRESSION", so for example the libpng constant
C<PNG_ITXT_COMPRESSION_zTXt> corresponds to a return value of
C<ITXT_zTXt>.

=head1 Library version functions

=head2 get_libpng_ver

    my $libpng_version = Image::PNG::Libpng::get_libpng_ver ();

This function returns the version of the libpng library which the
module is using.

[% cor(fn="get_libpng_ver") %]. However, it doesn't require the
C<png_structp> argument of the C function. [% unused %]

=head2 access_version_number

    my $libpng_version_number = Image::PNG::Libpng::access_version_number ();

This function returns the version of the libpng library which the
module is using as an integer number.

[% cor(fn="access_version_number") %].

=head1 Palettes

See [% spec("11PLTE") %] for information on the PNG standards for
the palette chunk.

=head2 get_PLTE

     my $colours = $png->get_PLTE ();
     # Get the green value of the twentieth entry in the palette.
     my $green = $colours->[20]->{green};

This function gets the palette from the PNG. The return value is an
array reference containing the palette. This array contains hash
references with the values "green", "blue" and "red" for the colour of
each pixel in the palette. If the PNG has no palette, it returns an
undefined value.

A PNG image may or may not contain a palette. To check whether the
image contains a palette, use something of the following form:

     use Image::PNG::Const ':all';
     my $color_type = $png->get_color_type ();
     if ($color_type == PNG_COLOR_TYPE_PALETTE) {
         # The PNG uses a palette.
     }

A PNG image may also contain a palette even when the "color_type" does
not indicate that. To check for that case, use L</get_valid>.

[% cor(fn="get_PLTE") %].

=head2 set_PLTE

    $png->set_PLTE ($palette);

Set the palette of C<$png>. The argument is an array reference
containing hash references. There is one hash reference for each
palette entry. The hash references contain three fields, red, green,
and blue, corresponding to the pixel value for that palette
entry. Other values in the hash references are ignored. For example,

    $png->set_PLTE ([{red => 1, green => 99, blue => 0x10},
                     {red => 0xFF, green => 0xFF, blue => 0xFF}]);

creates a palette with two entries in C<$png>.

[% cor(fn="set_PLTE") %].

=head1 Compression and filtering

=head2 set_filter

    use Image::PNG::Const 'PNG_FILTER_NONE';
    $png->set_filter (PNG_FILTER_NONE);

This sets the filters which are allowed to be used for writing a PNG
image. The possible values are

=over
[% FOR filter IN filters %]
=item [% filter.macro %]
[% END %]
=back

These can be combined using C<|> (logical or):

    use Image::PNG::Const ':all';
    set_filter ($png, PNG_FILTER_UP | PNG_FILTER_AVG);

Please see [% spec("9Filter-types") %] for the meanings of these
filter types.

[% cor(fn="set_filter") %] with the second (unused)
argument omitted. [% unused %]

=head2 set_user_limits

    $png->set_user_limits ($width, $height);

This enables a user to override libpng's restrictions to one million
pixels in width and one million pixels in height for a PNG image.

[% cor(fn="set_user_limits") %]

[% FOR what IN ['width', 'height'] %]

=head2 get_user_[% what %]_max

    $png->get_user_[% what %]_max ();

Get the maximum [% what %] allowed. These values can be changed by
L</set_user_limits>.

[% cor(fn="get_user_" _ what _ "_max") %]

[% END # what %]

=head2 set_compression_level

    $png->set_compression_level ($number);

Set the compression level used to make the PNG. A value of 0
corresponds to no compression at all, otherwise C<$number> may take
values of 1 to 9, with smaller values giving faster, and larger values
giving better, that is with smaller output, compression. These
correspond to the -1, -2, ... -9 options to the C<gzip> utility, or
the compression level parameter of C<zlib>. Calling with C<-1> reverts
to the default compression. Calling with any other number outside the
range 0 to 9 results in a fatal error.

([% danger %] The libpng documentation, and online sites derived from it,
incorrectly states that the underlying function
C<png_set_compression_level> takes only arguments from 0 to 9 and that
this function should be called with a value of 6 to obtain the default
compression; libpng in fact uses the value of -1 via the macro
C<PNG_Z_DEFAULT_COMPRESSION> to set its default compression. This may
be confirmed by examining the source code of F<pnglibconf.h>,
F<pngwrite.c>, and F<pngwutil.c> in the libpng
distribution. Image::PNG::Libpng supports the libpng default value of
-1 but doesn't allow other negative numbers. Whether or not the value
0 results in no compression is untested as of Image::PNG::Libpng
version 0.49.)

This function was added to the module in version 0.49.

[% MACRO untested(func) BLOCK %]
=head2 [% func %]

    $png->[% func %] ($argument);

[% danger %] Untested function corresponding to C<png_[%- func
-%]>. Takes one integer argument.

[%- END %]

[% untested("set_compression_mem_level") %]

Sets the C<memLevel> parameter of C<deflateInit2> in zlib when writing
PNG image data. Argument between 1 for minimum memory and 9 for
maximum speed. The default is 8. See L</zlib documentation>.

[% untested("set_compression_window_bits") %]

Sets the C<windowBits> parameter of C<deflateInit2> in zlib when
writing PNG image data. Argument value must be between 8 and 15 for
libpng. The default is 15. See the L</zlib documentation>.

[% untested("set_compression_strategy") %]

Sets the C<strategy> parameter of C<deflateInit2> when writing PNG
image data. Setting this with libpng overrides libpng's default
behaviour of changing the value depending on the filter in use. For
zlib, the argument is either 0 for default behaviour, or 1 to 4.  See
the L</zlib documentation>. libpng uses the default strategy 0
(C<Z_DEFAULT_STRATEGY>) for unfiltered image data, and 1
(C<Z_FILTERED>) for filtered image data.

[% untested("set_text_compression_level") %]

As L</set_compression_level> but for compressed text.

[% untested("set_text_compression_mem_level") %]

As L</set_compression_mem_level> but for compressed text.

[% untested("set_text_compression_window_bits") %]

As L</set_compression_window_bits> but for compressed text.

[% untested("set_text_compression_strategy") %]

As L</set_compression_strategy> but for compressed text.

=head1 Other chunks

These routines deal with the other possible chunks of PNGs.

The getter and setter routines for all other chunks are designed so
that the return value of C<get_wXYZ> is able to be used directly as
the value for C<set_wXYZ>, so the values of chunks can easily be
copied from one PNG to another.

    my $values = $png1->get_wXYZ ();
    $png2->set_wXYZ ($values);

If the chunk is not present, or if the chunk is not supported by the
user's version of libpng, the return value of C<get_wXYZ> is the
undefined value.

=head2 bKGD

The background colour of the PNG image.

See [% spec("11bKGD") %] for information on the PNG standards for
the background chunk.

=head3 get_bKGD

    my $bkgd = $png->get_bKGD ();

Get the bKGD (background) chunk of the image.

The return value is a hash with the following keys, depending on the
colour type of the image:

=over

=item index

For palette colour types, this is the offset into the palette.

=item gray

For greyscale colour types.

=item red

=item green

=item blue

=back

[% cor(fn="get_bKGD") %] with a hash function instead of a
C<png_color> struct.

=head3 set_bKGD

    $png->set_bKGD ($bkgd);

Set the bKGD (background) chunk of the image. C<$bkgd> is a hash
reference. The keys of the hash reference are as described in
L</get_bKGD>.

[% cor(fn="set_bKGD") %] with a hash function instead of a
C<png_color> struct.

=head2 cHRM

See [% spec("11cHRM") %] "cHRM Primary chromaticities and white
point".

=head3 get_cHRM

    my %cHRM = $png->get_cHRM ();

Get the cHRM chunk as a hash.

The keys of the hash are

=over
[% FOR key IN chunk_hash.cHRM.fields %]
=item [% key %]
[% END %]
=back

The values of the hash are floating point numbers between 0 and 1.

[% cor(fn="get_cHRM") %] with a hash function instead of the C<double>
arguments. The hash key names correspond to the names of the C<double>
arguments in libpng.

=head3 set_cHRM

    $png->set_cHRM (\%cHRM);

Set the cHRM chunk from a hash.

The keys of the hash are

=over
[% FOR key IN chunk_hash.cHRM.fields %]
=item [% key %]
[% END %]
=back

The values of the hash are floating point numbers between 0 and 1.

[% cor(fn="set_cHRM") %] with a hash function instead of the C<double>
arguments.

=head2 eXIf

The C<eXIf> chunk is an extension to the PNG specification. See
L<http://www.simplesystems.org/png-group/proposals/eXIf/>. Support for
this chunk was added in version 0.50 of this module.

=head3 get_eXIf

    my $exif = $png->get_eXIf ();

This retrieves the C<eXIf> chunk from C<$png> but does not process the
internal information.

=head3 set_eXIf

    $png->set_eXIf ($exif);

libpng checks whether the chunk's first two bytes are either C<II> for
little-endian (from Intel) or C<MM> for big-endian (from Motorola)
then adds the entire chunk, including the first two bytes, to the PNG.

[% danger %] As of December 2020, there appears to be a bug in libpng
in which the eXIf chunk is added twice, causing a warning of the form
C<libpng warning: eXIf: duplicate> on reading a PNG file back in. See
L<https://github.com/glennrp/libpng/pull/351>.

=head2 gAMA

See [% spec("11gAMA") %].

=head3 get_gAMA

    my $gamma = $png->get_gAMA ();

Get the gamma value or gAMA chunk. The return value is a
floating-point number.

[% cor(fn="get_gAMA") %]

=head3 set_gAMA

    $png->set_gAMA (0.2);

Set the gamma value or gAMA chunk.

[% cor(fn="set_gAMA") %]

=head2 sRGB

See [% spec("11sRGB") %].

=head3 get_sRGB

    my $sRGB = $png->get_sRGB ();

The return value is an integer number corresponding to one of the
following:

=over

=item PNG_sRGB_INTENT_SATURATION

=item PNG_sRGB_INTENT_PERCEPTUAL

=item PNG_sRGB_INTENT_ABSOLUTE

=item PNG_sRGB_INTENT_RELATIVE

=back

[% cor(fn="get_sRGB") %]

=head3 set_sRGB

    $png->set_sRGB ($srgb);

C<$srgb> is one of the following (integer numbers).

=over

=item PNG_sRGB_INTENT_SATURATION

=item PNG_sRGB_INTENT_PERCEPTUAL

=item PNG_sRGB_INTENT_ABSOLUTE

=item PNG_sRGB_INTENT_RELATIVE

=back

[% cor(fn="set_sRGB") %]

=head2 pHYs

See [% spec("11pHYs") %].

=head3 get_pHYs

    my $phys = $png->get_pHYs ();

The return value is a hash reference with the keys

=over

=item res_x

=item res_y

=item unit_type

=back

[% cor(fn="get_pHYs") %]

=head3 set_pHYs

    $png->set_pHYs ({res_x => 1, res_y => 1, unit_type => 99});

[% cor(fn="set_pHYs") %]

=head2 oFFs

This is an extension to the PNG specification. See L<http://www.libpng.org/pub/png/spec/1.1/pngext-1.1.0-pdg.html#C.oFFs>.

=head3 get_oFFs

    my $phys = $png->get_oFFs ();

Get oFFs chunk. Return value is a hash reference

[% cor(fn="get_oFFs") %]

=head3 set_oFFs

    $png->set_oFFs ({x_offset => 1, y_offset => 1, unit_type => 99});

Set oFFs chunk.

[% cor(fn="set_oFFs") %]

=head2 sBIT

See [% spec("11sBIT") %].

=head3 get_sBIT

    my $sbit = $png->get_sBIT ();

The return value is a hash reference containing integer values for the
keys C<red>, C<blue>, C<green>, and C<gray>.

[% cor(fn="get_sBIT") %]

=head3 set_sBIT

    $png->set_sBIT ({red => 1, blue => 2, green => 3});

The argument is a hash reference containing integer values for the
keys C<red>, C<blue>, C<green>, and C<gray>.

[% cor(fn="set_sBIT") %]

=head2 iCCP

See [% spec("11iCCP") %].

=head3 get_iCCP

    my $iccp = $png->get_iCCP ();

The return value is a hash with two keys,

=over

=item name

The name of the profile.

=item profile

The colour profile.

=back

The C<compression_type> value is not returned. [% unused %]

[% cor(fn="get_iCCP") %].

=head3 set_iCCP

    $png->set_iCCP ({name => 'name', profile => 'profile'});

[% cor(fn="set_iCCP") %]. The C<compression_type> argument is not
supported. [% unused %]

=head2 pCAL

pCAL is an extension of the PNG specification which allows one to
associate pixels in the PNG image with non-image data such as a heat
map. See
L<http://www.libpng.org/pub/png/spec/1.1/pngext-1.1.0-pdg.html#C.pCAL>.

[% supports(desc="the pCAL extension",val="pCAL") %]

=head3 get_pCAL

    my $pcal = $png->get_pCAL ();

[% danger %] Implemented but not tested. Return value is a hash with
the following keys:

=over

=item purpose

The purpose string of the pCAL chunk.

=item x0

The zero value for the equation.

=item x1

The max value for the equation.

=item type

The equation type as a number, from 0 to 3. See the PNG specification
for the meanings. Other numbers cause an error.

=item units

The units as a string. According to the PNG specification, "The units
for the physical values are given by the unit name, which may contain
any number of printable Latin-1 characters, with no limitation on the
number and position of blanks. For example, "K", "population density",
"MPa". A zero-length string can be used for dimensionless data."

=item params

If this exists, its value is a reference to an array containing the
parameter list of the pCAL chunk.

=back

[% cor(fn="get_pCAL") %]

[% danger %] libpng does not actually seem to implement reading of the
parameters of a pCAL chunk.

=head3 set_pCAL

    $png->set_pCAL ($values);

[% danger %] Implemented but not tested. The input is just the same as
the output of L</get_pCAL>.

[% cor(fn="set_pCAL") %]

=head2 hIST

See [% spec("11hIST") %].

=head3 get_hIST

    my $hist = $png->get_hIST ();

Return value is array reference. The number of entries in the array
reference is the same as in the palette.

[% cor(fn="get_hIST") %]

=head3 set_hIST

    $png->set_hIST (\@hist);

Set the histogram.

[% cor(fn="set_hIST") %]

=head2 sCAL

This is an extension to the PNG specification. See
L<http://www.libpng.org/pub/png/spec/1.1/pngext-1.1.0-pdg.html#C.sCAL>.

[% supports(desc="the sCAL chunk",val="sCAL") %]

=head3 get_sCAL

    my $scal = $png->get_sCAL ();

The returned hash value contains the following keys:

=over

=item unit

The unit type, which is either PNG_SCALE_UNKNOWN, PNG_SCALE_METER, or
PNG_SCALE_RADIAN.

=item width

The width, as a string.

=item height

The height, as a string.

=back


[% cor(fn="get_sCAL_s") %]. Note that this uses the sCAL_s function
rather than the get_sCAL and the returned values are the strings
themselves rather than parsed numbers.

=head3 set_sCAL

    $png->set_sCAL ($scal);

C<$scal> is a hash reference containing the keys described in
L</get_sCAL>.

[% cor(fn="set_sCAL_s") %]. Note that this uses the C<set_sCAL_s>
function rather than C<set_sCAL> and the input values are the strings
themselves rather than numbers.

=head2 sPLT

See [% spec("11sPLT") %].

=head3 get_sPLT

Provisional. See L</set_sPLT> for documentation, the return value is
like the input of that.

=head3 set_sPLT

    $png->set_sPLT ([{ name => 'palette', depth => 8, entries => [{red => 1, blue => 2},]}]);

Set suggested palettes. The input is an array reference containing
hash references with the following fields:

=over

=item name

The name of the suggested palette.

=item depth

The depth of the suggested palette.

=item entries

The entries of the palette. This is an array reference containing hash
references with keys as follows:

=over

=item red

=item blue

=item green

=item frequency

=item alpha

=back

=back

The field C<nentries> which is returned by L</get_sPLT> does not need
to be specified, it is calculated from the length of C<entries>.

=head2 tRNS

See [% spec("11tRNS") %].

=head3 get_tRNS

    my $trns = $png->get_tRNS ();

Get the C<tRNS> chunk. If the image is a palette type, this is an
array reference. If the image is a non-palette type, this is a hash
containing values for the keys red, green, blue, and gray.

=head3 set_tRNS

    $png->set_tRNS ($trns);

Set the C<tRNS> chunk. If the image is a palette type, C<$trns> is a
reference to an array of positive or zero values between 0 and 255 of
the same size as the palette. It must not contain more than 256
values. If the image is not a palette type, C<$trns> is a hash
reference containing values for the keys red, green, blue and gray.

=head1 META FUNCTIONS

These functions enable examination of the installed libpng from Perl.

=head2 libpng_supports

    if (libpng_supports ('iTXt')) {
        print "Your libpng supports international text.\n";
    }

This function returns true or false depending on whether the version
of libpng which this was compiled with supports or does not support a
particular facility.

The possible arguments to C<libpng_supports> are

=over

=item iTXt

Does the libpng support international text?

=item tEXt

Does the libpng support text?

=item zTXt

Does the libpng support compressed text?

=item sCAL

Does the libpng support the L</sCAL> extension?  This actually tests
for the presence of the C<get_sCAL_s>/C<set_sCAL_s> functions, so its
behaviour is dependent on other factors for versions 1.2 and 1.4 of
libpng.

=item pCAL

Does the libpng support the L</pCAL> extension?

=item sPLT

Does the libpng support L</sPLT> chunks?

=item UNKNOWN_CHUNKS

Does the libpng support unknown chunks (see L<Private chunks>)?

=back

=head1 UNDOCUMENTED FUNCTIONS

[% danger %] These functions aren't fully documented and are subject to
change. You can examine the source code or the libpng documentation to
discover their function.

=head2 set_filler

    $png->set_filler ($filler, $flags);

Set transformations in $png such that a filler byte C<$filler> is
added when an 8-bit grayscale image or 24-bit RGB image is read, and a
filler byte is deleted when an 8-bit grayscale image or 24-bit RGB
image is written. C<$flags> may be C<PNG_FLAG_FILLER_AFTER> or zero.

[% cor(fn="set_filler") %]

=head2 set_packing

    $png->set_packing ();

When reading a PNG, expand the image to 1 pixel per byte for
bit-depths 1, 2 and 4 without changing the order of the pixels. If not
called, pack pixels of bit_depths 1, 2 and 4 into bytes as small as
possible, for example, 8 pixels per byte for 1-bit files

[% cor(fn="set_packing") %]

=head2 set_strip_16

    $png->set_strip_16 ();

Strip the pixels of a PNG stream with 16 bits per channel to 8 bits
per channel.

[% cor(fn="set_strip_16") %]

=head2 set_expand

    $png->set_expand ();

Set transformation in C<$png> such that paletted images are expanded
to RGB, grayscale images of bit-depth less than 8 are expanded to
8-bit images, and tRNS chunks are expanded to alpha channels.

[% cor(fn="set_expand") %]

=head2 set_gray_to_rgb

    $png->set_gray_to_rgb ();

[% cor(fn="set_gray_to_rgb") %]

=head2 get_tRNS_palette

    $png->get_tRNS_palette ();

This is not a libpng-equivalent function.

=head2 set_PLTE_pointer

    $png->set_PLTE_pointer ();

This is not a libpng-equivalent function.

=head1 TESTING FUNCTIONS

=head2 image_data_diff

    my $diff = image_data_diff ('a.png', 'b.png');

This returns the undefined value if the image data in F<a.png> is the
same as the image data in F<b.png>. If the image data is different, it
returns a readable text message describing the first difference found,
for example the height is different, or row 0 of the image data is
different, etc. 

This function is used in testing this module. See also L</png_compare>.

=head1 ACCESS FUNCTIONS

These functions access the libpng C structures within the Perl
object. They are for people writing XS or C code.

=head2 get_internals

    my ($png_struct, $png_info) = get_internals ($png);

This function returns the C<png_structp> and C<png_infop> contained in
C<$png>. The return value is a list containing the C<png_structp> as
the first argument and the C<png_infop> as the second argument,
wrapped up as references to objects of type
C<Image::PNG::Libpng::png_struct> and C<Image::PNG::Libpng::png_info>.

To access the values of the pointers, use something like this:

    void access_png_internals (png, info)
	SV * png;
	SV * info;
    PREINIT:
	png_struct * cpng;
	png_info * cinfo;
    CODE:
	cpng = INT2PTR (png_struct *, SvIV (png));
	cinfo = INT2PTR (png_info *, SvIV (info));

An example exists in L<Image::PNG::Cairo>.    

=head2 copy_row_pointers

    $png->copy_row_pointers ($row_pointers);

This allows XS routines to directly set the value of the row pointers
for the PNG image. The memory is copied, so whatever is in the row
pointers can be freed immediately after calling this. However, the
image data it points to is not copied, so this needs to be valid until
the PNG is written.

The Perl scalar C<$row_pointers> should be set up something like the
following (where C<rp> is the C pointer):

    RETVAL = newSViv (PTR2IV (rp));

It's extracted from the Perl scalar using

    rp = INT2PTR (png_byte **, SvIV (row_pointers));

where row_pointers is the C<SV *> corresponding to C<$row_pointers> in
the Perl script. See also L</set_row_pointers> which does the same
thing but takes ownership of the memory.

=head2 set_image_data

    $png->set_image_data ($image_data);

Set the internal image data pointer to C<$image_data>. C<$image_data>
should contain a pointer to memory stored as an C<SvIV> allocated with
C<Newx> or a similar function. This transfers ownership of the memory
to C<$png>, which will free it with C<Safefree> when C<$png> is
destroyed. Calling this function with any value does not actually
change the content of the PNG image itself.

=head2 set_row_pointers

    $png->set_row_pointers ($row_pointers);

This sets the rows of the PNG image to C<$row_pointers> using
C<png_set_rows>. C<$row_pointers> must contain a pointer to memory
stored as an SvIV allocated with a Perl memory allocator like C<Newx>
or a similar function. This also transfers ownership of the memory to
C<$png>, which will free it with C<Safefree> when C<$png> is
destroyed. See also L</copy_row_pointers>, which does the same thing
except for the freeing of the memory.

=head1 EXPORTS

Nothing is exported by default, but all the functions in this module,
including the object methods, can be exported on request. The export
tag 'all' exports everything in the module:

    use Image::PNG::Libpng ':all';

This includes all the methods, which can then be used with the C<$png>
argument as the first argument.

=head1 Differences from libpng

The functions in Image::PNG::Libpng are closely based on those of
libpng, with the following differences.

=head2 [% noinfo %]

This module, C<Image::PNG::Libpng> does not use the "info"
structure of libpng. Almost all libpng functions require two initial
arguments, a C<png_structp> and a C<png_infop>. However, in 
Image::PNG::Libpng, both the "png" and the "info" are contained in
the first argument to each function.

=head2 [% unused_title %]

[% danger %] This module eliminates all the unevaluated arguments of
libpng. For example, libpng requires the user to pass a pointer to a
C<png_struct> to call the libpng version number function, (see
L</get_libpng_ver>), but it actually completely ignores this
structure. There are many similar instances of unevaluated arguments,
which have all been eliminated from this module.

If you are interested in exactly which libpng arguments are omitted,
you can find each instance [% perl_libpng_c %] in the macro
C<UNUSED_ZERO_ARG>.

=head2 Function return values are used to return values

libpng is very inconsistent in its calling conventions. Some functions
return results using references, and some return results using the
function's return value. For example C<png_get_rows> (see
L</get_rows>) uses the return value of the function to return an array
of pointers, but C<png_get_PLTE> (see L</get_PLTE>) uses a pointer
reference to return an array of pointers, and the return value to
indicate errors.

Image::PNG::Libpng uses only the return value. Errors and
non-existence are indicated by a return value of the undefined
value.

Further to this, libpng's error handling is also very inconsistent.
Some functions use the return value to indicate errors, and some of
the functions don't indicate errors at all, but just fail
silently. Even more inconsistently, some of the functions which use
the return value to indicate an error use a non-zero value, and some
use a zero value, to indicate an error.

=head2 No destructors

Freeing the memory allocated by L</create_read_struct> and
L</create_write_struct> is automatically handled by Perl.

Older versions of this module (pre-0.18) had functions called
C<destroy_read_struct> and C<destroy_write_struct> corresponding to
the functions with similar names in libpng. From version 0.18, these
functions still exist, but they no longer do anything. The memory
freeing is now handled by Perl automatically.

=head2 Other unimplemented parts of libpng

=over

=item Memory management functions

This module does not offer an interface to C<png_malloc> and C<png_free>.

=item Error handling functions

This module does not offer an interface to C<png_error> and
C<png_get_error_ptr> or any of the other error handling functions of
libpng. It redirects the error and warning handlers to Perl's error
stream.

=item Input/output manipulation functions

This module does not offer a direct interface to C<png_set_write_fn>
and C<png_set_read_fn>. However, it is possible to use their
functionality to access Perl data via L</read_from_scalar> and
L</write_to_scalar>.

=item Partial read/write functions

This module does not currently offer an interface to the partial read
and write functions of libpng. The reason is because I don't know
enough about Perl's internal structures to be able to create a
memory-safe interface to these functions. The partial read/write
functions would rely on preserving pointers to data structures within
the Perl program's data area between calls. So this module doesn't
deal with C<png_write_chunk>, C<png_write_end>, C<png_write_info>,
C<png_write_row>, or C<png_write_rows>.

=item Fixed point functions

There is currently no support for the PNG fixed point functions in
this Perl module, the functions with suffix C<_fixed>.

=item Other unsupported functions

Unsupported functions from the libpng API include the following:

=over

=item png_benign_error

=item png_chunk_benign_error

=item png_get_chunk_cache_max

=item png_get_compression_buffer_size

=item png_get_compression_type

=item png_get_filter_type

=item png_get_interlace_type

=item png_get_io_ptr

=item png_get_progressive_ptr

=item png_get_signature

=item png_get_x_offset_pixels

=item png_get_x_pixels_per_meter

=item png_get_y_offset_pixels

=item png_get_y_pixels_per_meter

=item png_set_benign_errors

=item png_set_cHRM_XYZ

There is no Z value allowed in L</set_cHRM> at present.

=item png_set_check_for_invalid_index

=item png_set_chunk_cache_max

=item png_set_compression_buffer_size

=item png_set_compression_method

[% danger %] This is a useless function in libpng corresponding to the
useless C<method> parameter of zlib functions like
C<deflateInit2>. See L</zlib documentation>. The libpng function just
produces a warning if the user sets the value to anything but 8, the
value of the macro C<Z_DEFLATED>, and then lets zlib produce an error.

=item png_set_text_compression_method

Unsupported for the same reasons as L</png_set_compression_method>.

=item png_set_crc_action

See L</Error handling functions>.

=item png_set_filter_heuristics

=item png_set_packswap

=item png_set_quantize

=item png_set_rgb_to_gray

=item png_set_scale_16

=item png_set_sig_bytes

=item png_set_strip_alpha

=item png_set_swap

=item png_set_tRNS_to_alpha

=item png_set_unknown_chunk_location

=item png_set_write_status_fn

=item png_get_eXIf

=item png_set_eXIf

The eXIf chunk is not supported yet.

=back

[% danger %] This is not an exhaustive list of libpng functions.

=back

=head1 DIAGNOSTICS

The module may produce the following error or warning messages. Errors
are marked "(F)" and warnings are marked "(W)".

=over
[% FOR diagnostic IN libpng_diagnostics %]

=item [% diagnostic.message %]

(
[%- IF diagnostic.type == "croak" -%]
F
[%- ELSIF diagnostic.type == "warn" -%]
W
[%- END -%]
) [% IF diagnostic.defined('comment') %]
[% diagnostic.comment %]
[% END %]

[% END %]

=back

=head1 BUGS

This section documents some known problems you may encounter.

=head2 Conditional compilation

It is possible to compile a version of the libpng library without
support for various things. For example, it's possible to have a
libpng without support for text chunks by undefining a macro
C<PNG_TEXT_SUPPORTED>. The module supports some of the conditional
compilation choices which I've found in practice, but it does not
support every possible choice. If you encounter problems using this
Perl module because of a conditionally-compiled libpng, then please
let me know and I'll consider adding that facility to the module.

=head2 init_io may crash

On some versions of Perl, L</init_io> may crash in some circumstances
with an error like "segmentation fault", if you use code like

    my $png = create_read_struct ();
    open my $file, "<:raw", "some.png";
    $png->init_io ($file);

and you do not check whether the call to C<open> was successful, and
F<some.png> does not exist. The crash occurs not within this module
but within Perl's conversion of C<$file> into a C C<FILE *> pointer,
because some older versions of Perl don't seem to check whether
C<$file> contains a valid C<FILE *> structure before dereferencing the
pointer. I believe this is a bug which has been fixed in Perls after
version 5.24.1. Because this problem occurs within code generated by
Perl itself, and not within this module's code, it is not feasible to
mitigate this, so please check the return value of C<open> in the
usual way, or use L<autodie>, to avoid this problem.

=head2 Not all constants are available

Some of the libpng constants are defined in F<pnglibconf.h> or
F<pngconf.h> but L<Image::PNG::Const> only looks at F<png.h> to make
its constants. Because of this, some constant values like
C<PNG_Z_DEFAULT_COMPRESSION> aren't currently available in
L<Image::PNG::Const>. This probably should be fixed to extract the
constants from the other files in a future version.

=head2 Issues with old versions of libpng

[% danger %] Some operating systems, in particular Linux systems, use
old versions of libpng. The following are known issues with older
libpng versions:

=head3 Text chunk handling

[% danger %] Versions of libpng up to 1.6.3 produce erratic results
with C<iTXt> (international text) chunks.

=head3 Compression level

[% danger %] Versions of libpng up to 1.5 behave erratically when
L</set_compression_level> or other C<set_compression_*> functions are
used to alter the compression of the image data.

=head1 STANDALONE SCRIPT

A standalone script, L<pnginspect>, is installed with the
distribution. It prints out the contents of the chunks of the PNG file
on the command line.

=head1 SEE ALSO

=head2 [% pngspec %]

[% INCLUDE "pngspec" %]

=head2 [% libpngdoc %]

=over

=item Official documentation

The starting point is the plain text libpng manual at
L<http://libpng.org/pub/png/libpng-manual.txt> and the manual page
libpng.3, which you can read using "man 3 libpng".

[% danger %] The documentation which comes with libpng is rather sketchy. See
L</Differences from libpng>. It doesn't contain full specifications
(prototypes, return values) for all of the functions in the
library. For programming in C using libpng, look at the header file
F<png.h>.  In some cases, you need to look at the source code of the
library.

=item Other documentation

There is a collection of function definitions under the title
"Interface Definitions for libpng12" at
L<https://refspecs.linuxbase.org/LSB_4.0.0/LSB-Desktop-generic/LSB-Desktop-generic/libpng12man.html>
as part of the "Linux Standard Base Desktop Specification". These
contain extensive information on the prototypes and return values for
the libpng routines, something which is often only available elsewhere
by actually looking at the libpng source code. These pages are usually
the first hits on search engines if you search for a function name in
libpng.

=back

=head2 zlib documentation

See L<https://zlib.net/manual.html> for the zlib documentation.

[% INCLUDE "other_modules" %]

[% INCLUDE "author" %]

